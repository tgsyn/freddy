// Freddy the Serial(isation) Killer
// 
// Released as open source by NCC Group Plc - https://www.nccgroup.trust/
//
// Project link: https://github.com/nccgroup/freddy/
//
// Released under agpl-3.0 see LICENSE for more information

package nb.freddy.modules;

import burp.*;
import nb.freddy.FreddyCollaboratorThread;
import nb.freddy.FreddyScanIssue;

import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Pattern;

/***********************************************************
 * Base class for Freddy scanner modules.
 *
 * TODO: Possibly unable to report Intruder-generated Collaborator issues
 * TODO: Unable to register time-based or Collaborator-based payloads
 *
 * TODO: Implement modules...
 *
 * Written by Nicky Bloor (@NickstaDB).
 **********************************************************/
public abstract class FreddyModuleBase {
    //Payload name constants
    protected static final String PN_ACTSURSEL = "ActivitySurrogateSelector";
    protected static final String PN_OBJDATPRO = "ObjectDataProvider";
    protected static final String PN_PSOBJ = "PSObject";
    protected static final String PN_TYPCONDEL = "TypeConfuseDelegate";
    protected static final String PN_WINID = "WindowsIdentity";
    protected static final String PN_BINDINGENUM = "BindingEnumeration";
    protected static final String PN_C3P0RDS = "C3P0RefDataSource";
    protected static final String PN_C3P0WCP = "C3P0WrapperConnPool";
    protected static final String PN_COMBEANUTILS = "CommonsBeanutils";
    protected static final String PN_COMMONSCONFIG = "CommonsConfiguration";
    protected static final String PN_GROOVY = "Groovy";
    protected static final String PN_IMAGEIO = "ImageIO";
    protected static final String PN_JDBC = "JdbcRowSet";
    protected static final String PN_LAZYSEARCH = "LazySearchEnumeration";
    protected static final String PN_RESIN = "Resin";
    protected static final String PN_RESOURCE = "ResourceGadget";
    protected static final String PN_ROME = "Rome";
    protected static final String PN_SCRIPT = "ScriptEngine";
    protected static final String PN_SERVICE = "ServiceLoader";
    protected static final String PN_SPRINGABF = "SpringAbstractBeanFactory";
    protected static final String PN_SPRINGPCA = "SpringPartiallyComparableAdvisor";
    protected static final String PN_SPRINGPPF = "SpringPropertyPathFactory";
    protected static final String PN_TEMPLATES = "Templates";
    protected static final String PN_UNICASTREF = "UnicastRef";
    protected static final String PN_XBEAN = "XBean";

    //Command line buffer size for RCE payloads
    private static final int BIN_PAYLOAD_CMD_BUFFER_SIZE = 200;

    //ASCII-HEX lookup tables
    private static final byte[] ASCHEX_LOOKUP = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66};
    private static final char[] ASCHEX_LOOKUP_TEXT = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    //A list of all collaborator payloads/records generated by this module (so they can be mapped back later)
    private final ArrayList<CollaboratorRecord> _collabRecords;
    //Passive scan indicators to identify potentially vulnerable targets
    private final ArrayList<ScanIndicator> _passiveReqIndicators;
    private final ArrayList<ScanIndicator> _passiveResIndicators;
    //Passive scan false positive indicators - used to avoid false positives e.g. where multiple libraries use "$type": in serialized JSON
    private final ArrayList<ScanIndicator> _passiveReqFPIndicators;
    private final ArrayList<ScanIndicator> _passiveResFPIndicators;
    //Active scan payloads
    private final ArrayList<ExceptionPayload> _exceptionBasedPayloads;
    private final ArrayList<TimeBasedPayload> _timeBasedPayloads;
    private final ArrayList<CollaboratorPayload> _collaboratorPayloads;
    //Burp objects
    private IBurpExtenderCallbacks _callbacks;
    private IExtensionHelpers _helpers;
    private IBurpCollaboratorClientContext _collabContext;
    //The name and platform of the target library/API
    private String _targetName;
    private TargetPlatform _targetPlatform;
    //Flag indicating whether this module is capable of testing for RCE (some attacks require non-generic payloads)
    private boolean _rceCapable;
    //Module-specific issue description caveats and remediation detail
    private String _descriptionCaveats;
    private String _remediationDetail;
    //Module-specific severity (e.g. some targets are dangerous but an attacker has to jump through additional hoops)
    private SeverityRating _severity;

    private long MAXINACTIVETIME = FreddyCollaboratorThread.COLLAB_POLL_INTERVAL * 5;

    /*******************
     * Default constructor - perform basic initialisation.
     ******************/
    public FreddyModuleBase() {
        _callbacks = null;
        _helpers = null;
        _collabContext = null;
        _collabRecords = new ArrayList<>();
        _targetName = null;
        _targetPlatform = null;
        _rceCapable = false;
        _descriptionCaveats = null;
        _remediationDetail = null;
        _severity = null;
        _passiveReqIndicators = new ArrayList<>();
        _passiveResIndicators = new ArrayList<>();
        _passiveReqFPIndicators = new ArrayList<>();
        _passiveResFPIndicators = new ArrayList<>();
        _exceptionBasedPayloads = new ArrayList<>();
        _timeBasedPayloads = new ArrayList<>();
        _collaboratorPayloads = new ArrayList<>();
    }

    /*******************
     * Initialise the module - mostly delegates to the abstract
     * initialiseModule() method to configure detection indicators and
     * payloads.
     *
     * @param callbacks The Burp callbacks object.
     ******************/
    public final void initialise(IBurpExtenderCallbacks callbacks) {
        _callbacks = callbacks;
        _helpers = _callbacks.getHelpers();
//        _collabContext = collabContext;
        initialiseModule();
    }

    /*******************
     * Abstract initialisation method.
     *
     * This should set the module name and platform, then register passive scan
     * indicators and active scan payloads and indicators.
     ******************/
    protected abstract void initialiseModule();

    /*******************
     * Set the name of the library/API targeted by this module.
     *
     * @param name The target library/API name.
     ******************/
    protected void setName(String name) {
        _targetName = name;
    }

    /*******************
     * Set the platform of the library/API targeted by this module.
     *
     * @param platform The platform of the target library/API.
     ******************/
    protected void setPlatform(TargetPlatform platform) {
        _targetPlatform = platform;
    }

    /*******************
     * Set the flag indicating whether this module is capable of testing for
     * RCE.
     *
     * Note that this is only a flag indicating whether the module is capable
     * of testing for RCE. All targets supported by Freddy can be exploited to
     * achieve RCE although some are more easily or readily exploitable than
     * others.
     *
     * @param capable True if the module can test for RCE.
     ******************/
    protected void setModuleIsRCECapable(boolean capable) {
        _rceCapable = capable;
    }

    /*******************
     * Set description caveats for issues generated by this module - for
     * example some modules rely on the presence of dependencies for
     * successful exploitation.
     *
     * @param caveats Caveats to append to the issue description generated by this module.
     ******************/
    protected void setDescriptionCaveats(String caveats) {
        _descriptionCaveats = caveats;
    }

    /*******************
     * Set module-specific remediation detail.
     *
     * @param detail Module-specific remediation details.
     ******************/
    protected void setRemediationDetail(String detail) {
        _remediationDetail = detail;
    }

    /*******************
     * Set the severity rating of this module/target.
     *
     * @param severity The severity rating for the target.
     ******************/
    protected void setSeverity(SeverityRating severity) {
        _severity = severity;
    }

    /*******************
     * Debug logging method.
     *
     * @param msg A message to log.
     ******************/
    protected void dbgLog(String msg) {
        PrintWriter pw = new PrintWriter(_callbacks.getStdout(), true);
        pw.println(msg);
    }

    /*******************
     * Right-pad a string with spaces to the given length.
     *
     * Useful for payload construction where ASCII-HEX data is included in a
     * text-based format.
     *
     * @param base The string to pad.
     * @param length The length to pad to.
     * @return The padded string.
     ******************/
    protected String padString(String base, int length) {
        return String.format("%1$-" + length + "s", base);
    }

    /*******************
     * Generate a regex pattern to match the base64 encoded string in a HTTP
     * request (where some characters are likely URL-encoded).
     *
     * @param b64 The base 64 encoded string to generate a pattern from.
     * @return The regex pattern that will match the given string.
     ******************/
    private Pattern generateBase64Pattern(String b64) {
        return Pattern.compile(b64.replace("/", "((\\/)|(%2f)|(%2F))").replace("+", "((\\+)|(%2b)|(%2B))"));
    }

    /*******************
     * Register a new string indicator for passive detection of the target
     * library or API.
     *
     * @param indicatorStr The string to search for.
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanIndicator(String indicatorStr, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqIndicators.add(new ScanIndicator(indicatorStr));
        } else {
            _passiveResIndicators.add(new ScanIndicator(indicatorStr));
        }
    }

    /*******************
     * Register a new regex indicator for passive detection of the target
     * library or API.
     *
     * @param indicatorPat The regular expression to search for.
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanIndicator(Pattern indicatorPat, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqIndicators.add(new ScanIndicator(indicatorPat));
        } else {
            _passiveResIndicators.add(new ScanIndicator(indicatorPat));
        }
    }

    /*******************
     * Register a new byte array indicator for passive detection of the target
     * library or API.
     *
     * Also generates a base 64 encoded string indicator.
     *
     * @param indicatorBytes The raw bytes to search for.
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanIndicator(byte[] indicatorBytes, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqIndicators.add(new ScanIndicator(indicatorBytes));
            _passiveReqIndicators.add(new ScanIndicator(generateBase64Pattern(_helpers.base64Encode(indicatorBytes))));
        } else {
            _passiveResIndicators.add(new ScanIndicator(indicatorBytes));
            _passiveResIndicators.add(new ScanIndicator(_helpers.base64Encode(indicatorBytes)));
        }
    }

    /*******************
     * Register a new multi-regex indicator for passive detection of the target
     * library or API.
     *
     * Multi-indicators are AND-based so will only return results if all
     * indicators are observed.
     *
     * @param indicatorPatterns An array of regular expression patterns to search for (all must be present to achieve a match).
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanIndicator(Pattern[] indicatorPatterns, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqIndicators.add(new ScanArrayIndicator(indicatorPatterns));
        } else {
            _passiveResIndicators.add(new ScanArrayIndicator(indicatorPatterns));
        }
    }

    /*******************
     * Register a regex indicator to prevent false positive results whilst
     * passively scanning.
     *
     * @param indicatorPattern The regular expression to check for.
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanFalsePositiveIndicator(Pattern indicatorPattern, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqFPIndicators.add(new ScanIndicator(indicatorPattern));
        } else {
            _passiveResFPIndicators.add(new ScanIndicator(indicatorPattern));
        }
    }

    /*******************
     * Register a multi-regex indicator to prevent false positive results
     * whilst passively scanning.
     *
     * @param indicatorPatterns An array of regular expression patterns to search for (all must be present to achieve a match).
     * @param target The target to search (request or response).
     ******************/
    protected void registerPassiveScanFalsePositiveIndicator(Pattern[] indicatorPatterns, IndicatorTarget target) {
        if (target == IndicatorTarget.REQUEST) {
            _passiveReqFPIndicators.add(new ScanArrayIndicator(indicatorPatterns));
        } else {
            _passiveResFPIndicators.add(new ScanArrayIndicator(indicatorPatterns));
        }
    }

    /*******************
     * Register a payload which should trigger an exception if deserialized,
     * along with a string that appears in the exception that would indicate a
     * vulnerable target.
     *
     * @param payloadStr The string that should trigger an exception when deserialized using the target library/API.
     * @param indicatorStr A string that appears in the exception that can be used to detect vulnerable targets.
     ******************/
    protected void registerActiveScanExceptionPayload(String payloadStr, String indicatorStr) {
        _exceptionBasedPayloads.add(new ExceptionPayload(_helpers.stringToBytes(payloadStr), indicatorStr));
    }

    /*******************
     * Register a payload which should trigger an exception if deserialized,
     * along with a regular expression to match part of the exception in order
     * to detect a vulnerable target.
     *
     * @param payloadStr The string that should trigger an exception when deserialized using the target library/API.
     * @param indicatorPat A regular expression that can be used to match the resulting exception and detect vulnerable targets.
     ******************/
    protected void registerActiveScanExceptionPayload(String payloadStr, Pattern indicatorPat) {
        _exceptionBasedPayloads.add(new ExceptionPayload(_helpers.stringToBytes(payloadStr), indicatorPat));
    }

    /*******************
     * Register a payload consisting of raw bytes which should trigger an
     * exception if deserialized, along with a string that appears in the
     * exception that would indicate a vulnerable target.
     *
     * This method also generates a base 64 encoded payload.
     *
     * @param payloadBytes The bytes that should trigger an exception when deserialized using the target library/API.
     * @param indicatorStr A string that appears in the exception that can be used to detect vulnerable targets.
     ******************/
    protected void registerActiveScanExceptionPayload(byte[] payloadBytes, String indicatorStr) {
        _exceptionBasedPayloads.add(new ExceptionPayload(payloadBytes, indicatorStr));
        _exceptionBasedPayloads.add(new ExceptionPayload(_helpers.stringToBytes(_helpers.base64Encode(payloadBytes)), indicatorStr));
    }

    /*******************
     * Register a payload consisting of raw bytes which should trigger an
     * exception if deserialized, along with a regex pattern that should match
     * the resulting exception to indicate a vulnerable target.
     *
     * @param payloadBytes The bytes that should trigger an exception when deserialized using the target library/API.
     * @param indicatorPattern A regex pattern to match the resulting exception and detect vulnerable targets.
     ******************/
    protected void registerActiveScanExceptionPayload(byte[] payloadBytes, Pattern indicatorPattern) {
        _exceptionBasedPayloads.add(new ExceptionPayload(payloadBytes, indicatorPattern));
        _exceptionBasedPayloads.add(new ExceptionPayload(_helpers.stringToBytes(_helpers.base64Encode(payloadBytes)), indicatorPattern));
    }

    /*******************
     * Register a text time-based active scanner payload.
     *
     * @param payload A payload that should trigger a time delay if deserialized by the target library/API.
     * @param timeDelay The expected time delay
     ******************/
    protected void registerActiveScanTimeBasedPayload(String payload, int timeDelay) {
        _timeBasedPayloads.add(new TimeBasedPayload(_helpers.stringToBytes(payload), timeDelay));
    }

    /*******************
     * Register a binary time-based active scanner payload.
     *
     * @param payloadBytes A payload that should trigger a time delay if deserialized by the target library/API.
     * @param timeDelay The expected time delay.
     ******************/
    protected void registerActiveScanTimeBasedPayload(byte[] payloadBytes, int timeDelay) {
        _timeBasedPayloads.add(new TimeBasedPayload(payloadBytes, timeDelay));
    }

    /*******************
     * Register an active scan payload for use with Burp Suite Collaborator.
     *
     * Note that Collaborator payloads must be generated on-the-fly and must
     * incorporate a unique identifier generated during scanning so this method
     * itself does not receive or generate payloads. Payload registration in
     * this instance causes the payload name to be registered. During an active
     * scan the method generateCollaboratorTextPayload() or
     * generateCollaboratorBytePayload() will be called with the payload name
     * and the unique Collaborator identifier (hostname) in order to generate
     * an appropriate payload.
     *
     * The active scan method automatically generates a base 64 encoded payload
     * if the payload is a binary one.
     *
     * @param payloadName The payload name.
     * @param isBinaryPayload True if the payload is binary, false if it is a text payload.
     ******************/
    protected void registerActiveScanCollaboratorPayload(String payloadName, boolean isBinaryPayload) {
        //Ensure the given name is unique
        for (CollaboratorPayload p : _collaboratorPayloads) {
            if (p.getPayloadName().equals(payloadName)) {
                throw new IllegalArgumentException("FreddyModuleBase::registerActiveScanCollaboratorPayload() must be called with a unique per-payload per-module name. The payload name " + payloadName + " has already been registered by the module " + _targetName + ".");
            }
        }
        _collaboratorPayloads.add(new CollaboratorPayload(payloadName, isBinaryPayload));
    }

    /*******************
     * Module implementations that are capable of generating RCE payloads that
     * are text based should override this method to generate a payload for use
     * with Burp Suite Collaborator.
     *
     * @param payloadName The payload name that was registered.
     * @param hostname The hostname that the payload should interact with.
     * @return The payload String.
     ******************/
    protected String generateCollaboratorTextPayload(String payloadName, String hostname) {
        return null;
    }

    /*******************
     * Module implementations that are capable of generating RCE payloads that
     * are not text based should override this method to generate a payload for
     * use with Burp Suite Collaborator.
     *
     * @param payloadName The payload name that was registered by the module.
     * @param hostname The hostname that the payload should resolve.
     * @return The payload bytes.
     ******************/
    protected byte[] generateCollaboratorBytePayload(String payloadName, String hostname) {
        return null;
    }

    /*******************
     * Build a binary payload buffer with space for a command line.
     *
     * Decodes the base 64 encoded prefix and suffix then copies them into a
     * new buffer with space for a payload command line in between.
     *
     * @param prefixB64 The payload prefix bytes in base 64 encoded form.
     * @param suffixB64 The payload suffix bytes in base 64 encoded form.
     * @param unicode True if the buffer for the command line should be filled with 2-byte unicode spaces, false for ASCII.
     * @return A byte array containing the final buffer.
     ******************/
    protected byte[] buildBinaryPayloadBuffer(String prefixB64, String suffixB64, boolean unicode) {
        byte[] prefixBytes, suffixBytes, payload;
        int i, payloadOffset = 0;

        //Decode prefix/suffix and create a buffer for the final payload
        prefixBytes = _helpers.base64Decode(prefixB64);
        suffixBytes = _helpers.base64Decode(suffixB64);
        payload = new byte[prefixBytes.length + suffixBytes.length + (unicode ? BIN_PAYLOAD_CMD_BUFFER_SIZE * 2 : BIN_PAYLOAD_CMD_BUFFER_SIZE)];

        //Build and return the buffer
        for (i = 0; i < prefixBytes.length; ++i) {
            payload[payloadOffset] = prefixBytes[i];
            payloadOffset += 1;
        }
        for (i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            payload[payloadOffset] = 0x20;
            payloadOffset += 1;
            if (unicode) {
                payload[payloadOffset] = 0x00;
                payloadOffset += 1;
            }
        }
        for (i = 0; i < suffixBytes.length; ++i) {
            payload[payloadOffset] = suffixBytes[i];
            payloadOffset += 1;
        }
        return payload;
    }

    /*******************
     * Build a binary payload buffer with space for a command line.
     *
     * Decodes the base 64 encoded prefix, middle, and suffix, then copies them
     * into a new buffer with space for a payload command line before and after
     * the middle chunk.
     *
     * @param prefixB64 The payload prefix bytes in base 64 encoded form.
     * @param midB64 The middle chunk of the payload in base 64 encoded form.
     * @param suffixB64 The payload suffix bytes in base 64 encoded form.
     * @param unicode True if the buffer for the command line should be filled with 2-byte unicode spaces, false for ASCII.
     * @return A byte array containing the final buffer.
     ******************/
    protected byte[] buildBinaryPayloadBuffer(String prefixB64, String midB64, String suffixB64, boolean unicode) {
        byte[] prefixBytes, middleBytes, suffixBytes, payload;
        int i, payloadOffset = 0;

        //Decode prefix/suffix and create a buffer for the final payload
        prefixBytes = _helpers.base64Decode(prefixB64);
        middleBytes = _helpers.base64Decode(midB64);
        suffixBytes = _helpers.base64Decode(suffixB64);
        payload = new byte[prefixBytes.length + middleBytes.length + suffixBytes.length + (unicode ? BIN_PAYLOAD_CMD_BUFFER_SIZE * 4 : BIN_PAYLOAD_CMD_BUFFER_SIZE * 2)];

        //Build and return the buffer
        for (i = 0; i < prefixBytes.length; ++i) {
            payload[payloadOffset] = prefixBytes[i];
            payloadOffset += 1;
        }
        for (i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            payload[payloadOffset] = 0x20;
            payloadOffset += 1;
            if (unicode) {
                payload[payloadOffset] = 0x00;
                payloadOffset += 1;
            }
        }
        for (i = 0; i < middleBytes.length; ++i) {
            payload[payloadOffset] = middleBytes[i];
            payloadOffset += 1;
        }
        for (i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            payload[payloadOffset] = 0x20;
            payloadOffset += 1;
            if (unicode) {
                payload[payloadOffset] = 0x00;
                payloadOffset += 1;
            }
        }
        for (i = 0; i < suffixBytes.length; ++i) {
            payload[payloadOffset] = suffixBytes[i];
            payloadOffset += 1;
        }
        return payload;
    }

    /*******************
     * Generate a binary payload buffer by overwriting an allocated space with
     * a given command line either as an ASCII or 2-byte unicode string.
     *
     * @param payloadBuffer The original payload buffer to modify with the given command line.
     * @param cmdOffset The offset into the buffer where the command line should begin.
     * @param cmdLine The command line to place in the buffer.
     * @param unicode True if the command line buffer expects a unicode string, false for ASCII.
     * @return The payload buffer passed in to the method containing the given command line.
     ******************/
    protected byte[] generateBinaryPayload(byte[] payloadBuffer, int cmdOffset, String cmdLine, boolean unicode) {
        byte[] cmdLineBytes;
        int payloadOffset, offsetInc;

        //Validate args
        if (cmdLine.length() > BIN_PAYLOAD_CMD_BUFFER_SIZE) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() must be called with a command that is shorter than " + BIN_PAYLOAD_CMD_BUFFER_SIZE + " characters in length. The supplied command was '" + cmdLine + "'.");
        }
        if (payloadBuffer.length < cmdOffset + (unicode ? BIN_PAYLOAD_CMD_BUFFER_SIZE * 2 : BIN_PAYLOAD_CMD_BUFFER_SIZE)) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() was called with a payload buffer that is not long enough to contain a " + BIN_PAYLOAD_CMD_BUFFER_SIZE + "-character command line from the supplied offset " + cmdOffset + ".");
        }

        //Write the command line into the payload bufufer at the given offset and return the result
        if (unicode) {
            offsetInc = 2;
        } else {
            offsetInc = 1;
        }
        cmdLineBytes = cmdLine.getBytes(StandardCharsets.US_ASCII);
        payloadOffset = cmdOffset;
        for (int i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            if (i < cmdLineBytes.length) {
                payloadBuffer[payloadOffset] = cmdLineBytes[i];
            } else {
                payloadBuffer[payloadOffset] = 0x20;
            }
            payloadOffset += offsetInc;
        }
        return payloadBuffer;
    }

    /*******************
     * Generate a binary payload buffer by overwriting an allocated space with
     * a given command line either as an ASCII or 2-byte unicode string.
     *
     * This method allows two offsets for the command line and repeats the
     * command line at both offsets to support certain payloads.
     *
     * @param payloadBuffer The original payload buffer to modify with the given command line.
     * @param cmdOffset1 The offset into the buffer where the first instance of the command line should begin.
     * @param cmdOffset2 The offset into the buffer where the second instance of the command line should begin.
     * @param cmdLine The command line to place in the buffer.
     * @param unicode True if the command line buffer expects a unicode string, false for ASCII.
     * @return The payload buffer passed in to the method containing the given command line.
     ******************/
    protected byte[] generateBinaryPayload(byte[] payloadBuffer, int cmdOffset1, int cmdOffset2, String cmdLine, boolean unicode) {
        byte[] cmdLineBytes;
        int payloadOffset1, payloadOffset2, offsetInc;

        //Validate args
        if (cmdLine.length() > BIN_PAYLOAD_CMD_BUFFER_SIZE) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() must be called with a command that is shorter than " + BIN_PAYLOAD_CMD_BUFFER_SIZE + " characters in length. The supplied command was '" + cmdLine + "'.");
        }
        if (cmdOffset1 >= cmdOffset2) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() was called with command line offset 1 and 2 in the wrong order.");
        }
        if (cmdOffset1 + (unicode ? BIN_PAYLOAD_CMD_BUFFER_SIZE * 2 : BIN_PAYLOAD_CMD_BUFFER_SIZE) > cmdOffset2) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() was called with overlapping command line offsets (" + cmdOffset1 + ", " + cmdOffset2 + ").");
        }
        if (payloadBuffer.length < cmdOffset2 + (unicode ? BIN_PAYLOAD_CMD_BUFFER_SIZE * 2 : BIN_PAYLOAD_CMD_BUFFER_SIZE)) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayload() was called with a payload buffer that is not long enough to contain a " + BIN_PAYLOAD_CMD_BUFFER_SIZE + "-character command line from the supplied offset " + cmdOffset2 + ".");
        }

        //Write the command line into the payload bufufer at the given offset and return the result
        if (unicode) {
            offsetInc = 2;
        } else {
            offsetInc = 1;
        }
        cmdLineBytes = cmdLine.getBytes(StandardCharsets.US_ASCII);
        payloadOffset1 = cmdOffset1;
        payloadOffset2 = cmdOffset2;
        for (int i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            if (i < cmdLineBytes.length) {
                payloadBuffer[payloadOffset1] = cmdLineBytes[i];
                payloadBuffer[payloadOffset2] = cmdLineBytes[i];
            } else {
                payloadBuffer[payloadOffset1] = 0x20;
                payloadBuffer[payloadOffset2] = 0x20;
            }
            payloadOffset1 += offsetInc;
            payloadOffset2 += offsetInc;
        }
        return payloadBuffer;
    }

    /*******************
     * Wrapper for generateBinaryPayload which base 64 encodes the resulting
     * buffer.
     *
     * @param payloadBuffer The original payload buffer to modify with the given command line.
     * @param cmdOffset The offset into the buffer where the command line should begin.
     * @param cmdLine The command line to place in the buffer.
     * @param unicode True if the command line buffer expects a unicode string, false for ASCII.
     * @return The payload buffer passed in to the method containing the given command line and base64 encoded.
     ******************/
    protected String generateBase64BinaryPayload(byte[] payloadBuffer, int cmdOffset, String cmdLine, boolean unicode) {
        return _helpers.base64Encode(generateBinaryPayload(payloadBuffer, cmdOffset, cmdLine, unicode));
    }

    /*******************
     * Generate a binary payload buffer by overwriting an allocated space with
     * a given command line, encoding the command line as ascii-hex.
     *
     * For example the command line "AA" becomes 0x34 31 34 31.
     *
     * @param payloadBuffer The original payload buffer to modify with the given command line.
     * @param cmdOffset The offset into the buffer where the command line should begin.
     * @param cmdLine The command line to place in the buffer.
     * @return The payload buffer passed in to the method containing the given command line.
     ******************/
    protected byte[] generateBinaryPayloadWithAscHexCommand(byte[] payloadBuffer, int cmdOffset, String cmdLine) {
        byte[] cmdLineBytes;
        int payloadOffset;

        //Validate args
        if (cmdLine.length() > BIN_PAYLOAD_CMD_BUFFER_SIZE) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayloadWithAscHexCommand() must be called with a command that is shorter than " + BIN_PAYLOAD_CMD_BUFFER_SIZE + " characters in length. The supplied command was '" + cmdLine + "'.");
        }
        if (payloadBuffer.length < cmdOffset + (BIN_PAYLOAD_CMD_BUFFER_SIZE * 2)) {
            throw new IllegalArgumentException("FreddyModuleBase::generateBinaryPayloadWithAscHexCommand() was called with a payload buffer that is not long enough to contain a " + BIN_PAYLOAD_CMD_BUFFER_SIZE + "-character command line from the supplied offset " + cmdOffset + ".");
        }

        //Write the command line into the payload bufufer at the given offset and return the result
        cmdLineBytes = cmdLine.getBytes(StandardCharsets.US_ASCII);
        payloadOffset = cmdOffset;
        for (int i = 0; i < BIN_PAYLOAD_CMD_BUFFER_SIZE; ++i) {
            if (i < cmdLineBytes.length) {
                payloadBuffer[payloadOffset] = ASCHEX_LOOKUP[cmdLineBytes[i] >> 4];
                payloadBuffer[payloadOffset + 1] = ASCHEX_LOOKUP[cmdLineBytes[i] & 0xf];
            } else {
                //Insert an ascii-hex encoded space (0x20 => 0x32 30)
                payloadBuffer[payloadOffset] = 0x32;
                payloadBuffer[payloadOffset + 1] = 0x30;
            }
            payloadOffset += 2;
        }
        return payloadBuffer;
    }

    /*******************
     * Encodes the given string as ascii-hex.
     *
     * @param base The string to encode.
     * @return The encoded string.
     ******************/
    protected String encodeStringToAsciiHex(String base) {
        StringBuilder sb = new StringBuilder();
        byte[] strBytes = base.getBytes(StandardCharsets.US_ASCII);
        for (byte strByte : strBytes) {
            sb.append(ASCHEX_LOOKUP_TEXT[((strByte) >> 4) & 0xf]);
            sb.append(ASCHEX_LOOKUP_TEXT[(strByte) & 0xf]);
        }
        return sb.toString();
    }

    /*******************
     * Encodes the given string as ascii byte values separated with commas.
     *
     * @param base The string to encode.
     * @return The encoded string.
     ******************/
    protected String encodeStringAsAsciiByteValues(String base) {
        StringBuilder sb = new StringBuilder();
        byte[] strBytes = base.getBytes(StandardCharsets.US_ASCII);
        for (byte strByte : strBytes) {
            sb.append(((int) strByte));
            sb.append(",");
        }
        return sb.toString();
    }

    /*******************
     * Perform a passive scan of the given HTTP request and response by checking
     * for indicators registered by the abstract initialiseModule() method.
     *
     * @param baseReqRes The HTTP request and response object provided by Burp.
     * @param requestStr The HTTP request converted to a string.
     * @param responseStr The HTTP response converted to a string.
     * @return A list of identified issues.
     ******************/
    public List<IScanIssue> doPassiveScan(IHttpRequestResponse baseReqRes, String requestStr, String responseStr) {
        ArrayList<IScanIssue> issues = new ArrayList<>();
        ArrayList<int[]> requestMarkers = new ArrayList<>();
        ArrayList<int[]> responseMarkers = new ArrayList<>();
        ArrayList<int[]> currentMarkers;

        //Check for false positive indicators in the request
        for (ScanIndicator indicator : _passiveReqFPIndicators) {
            if (indicator.isTextBased()) {
                currentMarkers = indicator.findInstances(requestStr);
            } else {
                currentMarkers = indicator.findInstances(baseReqRes.getResponse());
            }
            if (currentMarkers != null && currentMarkers.size() > 0) {
                return null;
            }
        }

        //Check for false positive indicators in the response
        for (ScanIndicator indicator : _passiveResFPIndicators) {
            if (indicator.isTextBased()) {
                currentMarkers = indicator.findInstances(requestStr);
            } else {
                currentMarkers = indicator.findInstances(baseReqRes.getResponse());
            }
            if (currentMarkers != null && currentMarkers.size() > 0) {
                return null;
            }
        }

        //Check for indicators in the request
        for (ScanIndicator indicator : _passiveReqIndicators) {
            if (indicator.isTextBased()) {
                currentMarkers = indicator.findInstances(requestStr);
            } else {
                currentMarkers = indicator.findInstances(baseReqRes.getRequest());
            }

            //Add the markers to the list of request markers
            if (currentMarkers != null && currentMarkers.size() > 0) {
                requestMarkers.addAll(currentMarkers);
            }
        }

        //Check for indicators in the response
        for (ScanIndicator indicator : _passiveResIndicators) {
            if (indicator.isTextBased()) {
                currentMarkers = indicator.findInstances(responseStr);
            } else {
                currentMarkers = indicator.findInstances(baseReqRes.getResponse());
            }

            //Add the markers to the list of response markers
            if (currentMarkers != null && currentMarkers.size() > 0) {
                responseMarkers.addAll(currentMarkers);
            }
        }

        //Generate and return an issue if any markers were found
        if (requestMarkers.size() > 0 || responseMarkers.size() > 0) {
            issues.add(createPassiveScanIssue(baseReqRes, requestMarkers, responseMarkers));
        }
        return issues;
    }

    /*******************
     * Perform an active scan of the given HTTP request and insertion point
     * using all module-specific payloads (exception-based, ping/time-based,
     * and DNS lookup/Collaborator-based).
     *
     * @param baseReqRes The base HTTP request and response being scanned.
     * @param insertionPoint The insertion point to scan.
     * @return A list of identified issues.
     ******************/
    public List<IScanIssue> doActiveScan(IHttpRequestResponse baseReqRes, IScannerInsertionPoint insertionPoint) {
        ArrayList<IScanIssue> issues = new ArrayList<>();
        ArrayList<int[]> reqMarkers = new ArrayList<>();
        ArrayList<int[]> currentMarkers;
        IHttpRequestResponse newReqRes;
        String responseStr;
        String collabId;
        byte[] payloadBytes;
        long requestStartTime;
        long baseRequestTime;
        long requestTime;

        //Test exception-based payloads
        for (ExceptionPayload p : _exceptionBasedPayloads) {
            payloadBytes = p.getPayloadBytes();
            newReqRes = _callbacks.makeHttpRequest(baseReqRes.getHttpService(), insertionPoint.buildRequest(payloadBytes));
            if (newReqRes.getResponse() != null) {
                responseStr = _helpers.bytesToString(newReqRes.getResponse());
                currentMarkers = p.findIndicator(responseStr);
                if (currentMarkers != null && currentMarkers.size() > 0) {
                    reqMarkers.add(insertionPoint.getPayloadOffsets(payloadBytes));
                    issues.add(createActiveScanExceptionBasedIssue(baseReqRes, newReqRes, reqMarkers, currentMarkers));
                    break;
                }
            }
        }

        //Test time-based payloads
        if (_timeBasedPayloads.size() > 0) {
            reqMarkers = new ArrayList<>();
            requestStartTime = System.currentTimeMillis();
            _callbacks.makeHttpRequest(baseReqRes.getHttpService(), insertionPoint.buildRequest(_helpers.stringToBytes(insertionPoint.getBaseValue())));
            baseRequestTime = System.currentTimeMillis() - requestStartTime;
            for (TimeBasedPayload p : _timeBasedPayloads) {
                payloadBytes = p.getPayloadBytes();
                requestStartTime = System.currentTimeMillis();
                newReqRes = _callbacks.makeHttpRequest(baseReqRes.getHttpService(), insertionPoint.buildRequest(payloadBytes));
                requestTime = System.currentTimeMillis() - requestStartTime;
                if (newReqRes.getResponse() != null && requestTime > (baseRequestTime + p.getTimeDelay())) {
                    reqMarkers.add(insertionPoint.getPayloadOffsets(payloadBytes));
                    issues.add(createActiveScanTimeBasedIssue(baseReqRes, newReqRes, reqMarkers, baseRequestTime, requestTime));
                    break;
                }
            }
        }

        //Issue collaborator-based payloads
        if (_rceCapable) {
//            TODO SB generate new collabContext
            try {
                _collabContext = _callbacks.createBurpCollaboratorClientContext();
                for (CollaboratorPayload p : _collaboratorPayloads) {
                    collabId = _collabContext.generatePayload(false);
                    if (!p.isBinary()) {
                        try {
                            payloadBytes = _helpers.stringToBytes(generateCollaboratorTextPayload(p.getPayloadName(), collabId + "." + _collabContext.getCollaboratorServerLocation()));
                        } catch (NullPointerException npe) {
                            dbgLog("[-] Null pointer exception in " + _targetName);
                            throw npe;
                        }
                    } else {
                        payloadBytes = generateCollaboratorBytePayload(p.getPayloadName(), collabId + "." + _collabContext.getCollaboratorServerLocation());
                    }
                    if (payloadBytes == null) {
                        throw new IllegalStateException("The module " + _targetName + " is flagged as RCE-capable " +
                                "but the payload generator method returned null for the '" + p.getPayloadName() +
                                "' payload, indicating that it may not have been implemented correctly.");
                    }
                    newReqRes = _callbacks.makeHttpRequest(baseReqRes.getHttpService(), insertionPoint.buildRequest(payloadBytes));
                    reqMarkers = new ArrayList<>();
                    reqMarkers.add(insertionPoint.getPayloadOffsets(payloadBytes));
                    _collabRecords.add(new CollaboratorRecord(collabId, collabId + "." + _collabContext.getCollaboratorServerLocation(), baseReqRes, newReqRes, reqMarkers, true));

                    //Repeat with a base 64 encoded payload if the payload is a binary one
                    if (p.isBinary()) {
                        collabId = _collabContext.generatePayload(false);
                        payloadBytes = _helpers.stringToBytes(_helpers.base64Encode(generateCollaboratorBytePayload(p.getPayloadName(), collabId + "." + _collabContext.getCollaboratorServerLocation())));
                        if (payloadBytes == null) {
                            throw new IllegalStateException("The module " + _targetName + " is flagged as RCE-capable " +
                                    "but the payload generator method returned null for the '" + p.getPayloadName() +
                                    "' payload, indicating that it may not have been implemented correctly.");
                        }
                        newReqRes = _callbacks.makeHttpRequest(baseReqRes.getHttpService(), insertionPoint.buildRequest(payloadBytes));
                        reqMarkers = new ArrayList<>();
                        reqMarkers.add(insertionPoint.getPayloadOffsets(payloadBytes));
                        _collabRecords.add(new CollaboratorRecord(collabId, collabId + "." + _collabContext.getCollaboratorServerLocation(), baseReqRes, newReqRes, reqMarkers, true));
                    }
                }

            } catch(java.lang.IllegalStateException ex) {
                // Burpsuite Collaborator is explicitly disabled
                dbgLog("[-] @" + this.getClass().getSimpleName() + " java.lang.IllegalStateException: " + ex.getMessage());
            }
        }

        //Return any identified issues
        return issues;
    }

    /*******************
     * Handle Collaborator server interactions for this module.
     *
     * @param interaction The Collaborator interaction object.
     * @return True if the interaction was generated and handled by this module.
     ******************/
    public boolean handleCollaboratorInteraction(IBurpCollaboratorInteraction interaction) {
        String interactionId = interaction.getProperty("interaction_id");
        boolean result = false;
        Iterator<CollaboratorRecord> iterator = _collabRecords.iterator();
        while (iterator.hasNext()) {
            CollaboratorRecord record = iterator.next();
            if (record.getCollaboratorId().equals(interactionId)) {
                try {
                    _callbacks.addScanIssue(createCollaboratorIssue(record, interaction));
                } catch (Exception ex) {
                    dbgLog("FreddyModuleBase[" + _targetName + "]::handleCollaboratorInteraction() exception: " + ex.getMessage());
                }
                iterator.remove();
                result = true;
            }
        }

        return result;
    }


    /**
     * Iterates over all collaborator records and removes those that are still present after 5 minutes.
     */
    public void removeInactiveCollaboratorRecords() {
        Iterator<CollaboratorRecord> iterator = _collabRecords.iterator();
        long now = System.currentTimeMillis();
        while (iterator.hasNext()) {
            CollaboratorRecord record = iterator.next();
            if ((now - record.getTimeStamp()) > MAXINACTIVETIME) {
                iterator.remove();

            }
        }
    }

    /*******************
     * Generate a new passive scan issue.
     *
     * @param baseReqRes The HTTP request and response that were scanned.
     * @param reqMarkers Markers indicating something of interest in the request.
     * @param resMarkers Markers indicating something of interest in the response.
     * @return A FreddyScanIssue describing the identified issue.
     ******************/
    private IScanIssue createPassiveScanIssue(IHttpRequestResponse baseReqRes, List<int[]> reqMarkers, List<int[]> resMarkers) {
        String issueDescription = "";
        String issueRemediation;
        ConfidenceRating confidence;
        SeverityRating severity;

        //Generate the issue description string
        if (reqMarkers.size() > 0 && resMarkers.size() > 0) {
            issueDescription += "The HTTP request and response ";
        } else if (reqMarkers.size() > 0) {
            issueDescription += "The HTTP request ";
        } else if (resMarkers.size() > 0) {
            issueDescription += "The HTTP response ";
        }
        issueDescription += "indicates that the application may be deserializing data using the <strong>" +
                _targetName + "</strong> library/API. An attacker may be able to supply arbitrary " +
                "serialized objects to the application which, if deserialized without proper prior validation" +
                ", could lead to arbitrary code execution.";
        if (_rceCapable) {
            issueDescription += " Consider performing an active scan or Intruder attack using the Freddy " +
                    "payload gnerator against the serialized data in the given request in order to verify " +
                    "whether the application is vulnerable to RCE.";
        }
        if (_descriptionCaveats != null) {
            issueDescription += " " + _descriptionCaveats;
        }

        //Generate the remediation string
        issueRemediation = "Untrusted data should never be passed to the <strong>" + _targetName + "</strong>" +
                " library/API without appropriately restricting the types that can be deserialized or without" +
                " proper prior validation to ensure that the data only contains objects of expected types. " +
                "All types/classes that the application allows to be deserialized should be reviewed to " +
                "ensure that dangerous behaviour cannot be ";
        issueRemediation += "triggered by deserializing objects of those types.";
        if (_remediationDetail != null) {
            issueRemediation += " " + _remediationDetail;
        }

        //Set confidence and severity
        if (reqMarkers.size() > 0 && resMarkers.size() > 0) {
            confidence = ConfidenceRating.FIRM;
            severity = _severity;
        } else {
            confidence = ConfidenceRating.TENTATIVE;
            severity = _severity;
        }

        //Generate and return a new scan issue
        return new FreddyScanIssue(
                "Detected Deserialization: " + _targetName,
                issueDescription,
                issueRemediation,
                confidence.toString(),
                severity.toString(),
                _helpers.analyzeRequest(baseReqRes).getUrl(),
                baseReqRes.getHttpService(),
                new IHttpRequestResponse[]{
                        _callbacks.applyMarkers(baseReqRes, reqMarkers, resMarkers)
                }
        );
    }

    /*******************
     * Generate a new active scan issue for exception-based detections.
     *
     * @param baseReqRes The initial HTTP request and response that were scanned.
     * @param newReqRes The generated HTTP request and response including the payload and exception indicators.
     * @param reqMarkers Markers for the payload in the generated HTTP request.
     * @param resMarkers Markers for the exception string(s) in the HTTP response.
     * @return A FreddyScanIssue describing the identified issue.
     ******************/
    private IScanIssue createActiveScanExceptionBasedIssue(IHttpRequestResponse baseReqRes, IHttpRequestResponse newReqRes, List<int[]> reqMarkers, List<int[]> resMarkers) {
        String issueDescription;
        String issueRemediation;

        //Generate the issue description string
        issueDescription = "A payload was inserted into the HTTP request that would trigger a specific " +
                "exception if it were deserialized by the <strong>" + _targetName + "</strong> library/API. " +
                "The presence of that exception in the HTTP response gives a strong indicator that the " +
                "application is using <strong>" + _targetName + "</strong> to deserialize user-supplied " +
                "data. If the application does not properly validate or filter the data prior to or during " +
                "deserialization then an attacker may be able to instantiate arbitrary objects, potentially " +
                "leading to arbitrary code execution.";
        if (_rceCapable) {
            issueDescription += " RCE payloads are included within Freddy for this library/API. Consider " +
                    "performing an active scan or Intruder attack using the Freddy payload generator against " +
                    "the given HTTP request in order to verify whether the application is vulnerable to RCE.";
        }
        if (_descriptionCaveats != null) {
            issueDescription += " " + _descriptionCaveats;
        }

        //Generate the remediation string
        issueRemediation = "Untrusted data should never be passed to the <strong>" + _targetName + "</strong>" +
                " library/API without appropriately restricting the types that can be deserialized or without" +
                " proper prior validation to ensure that the data only contains objects of expected types. " +
                "All types/classes that the application allows to be deserialized should be reviewed to " +
                "ensure that dangerous behaviour cannot be ";
        issueRemediation += "triggered by deserializing objects of those types.";
        if (_remediationDetail != null) {
            issueRemediation += " " + _remediationDetail;
        }

        //Generate and return the new scan issue
        return new FreddyScanIssue(
                "Detected Deserialization: " + _targetName,
                issueDescription,
                issueRemediation,
                ConfidenceRating.CERTAIN.toString(),
                _severity.toString(),
                _helpers.analyzeRequest(baseReqRes).getUrl(),
                baseReqRes.getHttpService(),
                new IHttpRequestResponse[]{
                        baseReqRes,
                        _callbacks.applyMarkers(newReqRes, reqMarkers, resMarkers)
                }
        );
    }

    /*******************
     * Generate a new active scan issue for a time-based detection.
     *
     * @param baseReqRes The initial HTTP request and response that were scanned.
     * @param newReqRes The generated HTTP request and response including the payload used.
     * @param reqMarkers Markers for the payload in the generated HTTP request.
     * @return A FreddyScanIssue describing the identified issue.
     ******************/
    private IScanIssue createActiveScanTimeBasedIssue(IHttpRequestResponse baseReqRes, IHttpRequestResponse newReqRes, List<int[]> reqMarkers, long baseTime, long newTime) {
        String issueDescription;
        String issueRemediation;

        //Generate the issue description string
        issueDescription = "A payload was inserted into the HTTP request that would trigger a time delay " +
                "if it were unsecurely deserialized using the <strong>" + _targetName + "</strong> " +
                "library/API. The base HTTP request took <strong>" + baseTime + "ms</strong> to execute, " +
                "whereas the request containing the payload took <strong>" + newTime + "ms</strong>, " +
                "indicating that the application is deserializing arbitrary objects using the <strong>" +
                _targetName + "</strong> library/API and is vulnerable to arbitrary code execution.";

        //Generate the remediation string
        issueRemediation = "Untrusted data should never be passed to the <strong>" + _targetName + "</strong>" +
                " library/API without appropriately restricting the types that can be deserialized or without" +
                " proper prior validation to ensure that the data only contains objects of expected types. " +
                "All types/classes that the application allows to be deserialized should be reviewed to " +
                "ensure that dangerous behaviour cannot be ";
        issueRemediation += "triggered by deserializing objects of those types.";
        if (_remediationDetail != null) {
            issueRemediation += " " + _remediationDetail;
        }

        //Generate and return the new scan issue
        return new FreddyScanIssue(
                "Detected Deserialization RCE: " + _targetName,
                issueDescription,
                issueRemediation,
                ConfidenceRating.CERTAIN.toString(),
                _severity.toString(),
                _helpers.analyzeRequest(baseReqRes).getUrl(),
                baseReqRes.getHttpService(),
                new IHttpRequestResponse[]{
                        baseReqRes,
                        _callbacks.applyMarkers(newReqRes, reqMarkers, null)
                }
        );
    }

    /*******************
     * Generate a new issue from a Collaborator interaction.
     *
     * This method overrides the module severity with HIGH because collaborator
     * requests are almost certainly the result of successful exploitation of
     * RCE (whereas a module may reduce the standard severity to medium due to
     * other exploitation requirements such as controlling the deserialization
     * type).
     *
     * @param record The Collaborator record containing details of the original request and payload.
     * @param interaction The Burp Collaborator interaction object.
     * @return A FreddyScanIssue describing the identified issue.
     ******************/
    private IScanIssue createCollaboratorIssue(CollaboratorRecord record, IBurpCollaboratorInteraction interaction) {
        String issueDescription;
        String issueRemediation;

        //Generate the issue description string
        issueDescription = "A payload was inserted into the HTTP request that would trigger a Burp Suite " +
                "Collaborator interaction if it were unsecurely deserialized using the <strong>" + _targetName +
                "</strong> library/API. This resulted in a ";
        if (interaction.getProperty("type").equalsIgnoreCase("dns")) {
            issueDescription += "DNS " + interaction.getProperty("query_type") + " query for " +
                    record.getHostname();
        } else {
            issueDescription += "HTTP request to " + interaction.getProperty("protocol") + "://" +
                    record.getHostname();
        }
        issueDescription += ". This indicates that the application is deserializing arbitrary objects using " +
                "the <strong>" + _targetName + "</strong> library/API and is vulnerable to arbitrary code " +
                "execution.";

        //Generate the remediation string
        issueRemediation = "Untrusted data should never be passed to the <strong>" + _targetName + "</strong>" +
                " library/API without appropriately restricting the types that can be deserialized or without" +
                " proper prior validation to ensure that the data only contains objects of expected types. " +
                "All types/classes that the application allows to be deserialized should be reviewed to " +
                "ensure that dangerous behaviour cannot be ";
        issueRemediation += "triggered by deserializing objects of those types.";
        if (_remediationDetail != null) {
            issueRemediation += " " + _remediationDetail;
        }

        //Generate and return the new scan issue
        return new FreddyScanIssue(
                "Detected Deserialization RCE (Collaborator): " + _targetName,
                issueDescription,
                issueRemediation,
                ConfidenceRating.CERTAIN.toString(),
                SeverityRating.HIGH.toString(),
                _helpers.analyzeRequest(record.getHttpService(), record.getRequestBody()).getUrl(),
                record.getHttpService(),
                new IHttpRequestResponse[]{
                        record.getBaseRequestResponse(),
                        _callbacks.applyMarkers(record.getNewRequestResponse(), record.getRequestMarkers(), null)
                }
        );
    }

    public ArrayList<ExceptionPayload> getErrorBasedPayloads() {
        return _exceptionBasedPayloads;
    }

    public ArrayList<Payload> getRCEPayloads(IIntruderAttack attack) {
        ArrayList<Payload> result = new ArrayList<>();

        try {
            _collabContext = _callbacks.createBurpCollaboratorClientContext();

        } catch(java.lang.IllegalStateException ex) {
            // Burpsuite Collaborator is explicitly disabled
            dbgLog("[-] @" + this.getClass().getSimpleName() + " java.lang.IllegalStateException: " + ex.getMessage());
            return result;
        }

        String collabId = _collabContext.generatePayload(false);
        String host = _collabContext.getCollaboratorServerLocation();
        StringBuffer sb = new StringBuffer();
        sb.append(collabId);
        sb.append(".");
        sb.append(host);
        if (_timeBasedPayloads.size() > 0) result.addAll(_timeBasedPayloads);
        for (CollaboratorPayload payload : _collaboratorPayloads) {
            Payload p;
            if (payload.isBinary()) {
                p = new Payload(generateCollaboratorBytePayload(payload.getPayloadName(), sb.toString()));
            } else {
                p = new Payload(generateCollaboratorTextPayload(payload.getPayloadName(), sb.toString()).getBytes());
            }
            result.add(p);
        }
        return result;
    }
}
